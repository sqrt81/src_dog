#include "dog_control/physics/FloatingBaseModel.h"

#include <cassert>
#include <iostream>

namespace dog_control
{

namespace physics
{

namespace spatial
{

int FloatingBaseModel::AddLink(const NodeDescription &node, int parent)
{
    // the link's parent must have a smaller id
    assert(static_cast<unsigned>(parent) <= node_description_.size());

    const int link_id = node_description_.size() + 1;

    // only the first link could have a floating joint
    assert((link_id != 1) xor (node.joint_type == floating));
    assert((link_id != 1) xor (parent == 0));

    node_description_.push_back(node);
    parent_.push_back(parent - 1);

    return link_id;
}

int FloatingBaseModel::AddEndEffector(int link_id,
                                      const Eigen::Vector3d &ee_local_pos)
{
    assert(static_cast<unsigned>(link_id - 1) < node_description_.size());

    const int ee_id = ee_local_pos.size();

    ee_info_.push_back({ee_local_pos, link_id - 1});

    return ee_id;
}

void FloatingBaseModel::SetJointMotionState(FBJSCRef stat)
{
    // exclude the floating base
    const size_t joint_size = node_description_.size() - 1;

    assert(stat.q.size() == joint_size);
    assert(stat.dq.size() == joint_size);

    js_ = stat;

    kinematics_updated_ = false;
    bias_force_updated_ = false;
    mass_matrix_updated_ = false;
}

void FloatingBaseModel::ForwardKinematics()
{
    if(kinematics_updated_)
        return;

    const size_t node_cnt = node_description_.size();
    v_.resize(node_cnt);
    X_parent_.resize(node_cnt);
    X0_.resize(node_cnt);
    a_C_.resize(node_cnt);

    v_rot_.resize(node_cnt);
    X_parent_rot_.resize(node_cnt);
    X0_rot_.resize(node_cnt);
    a_C_rot_.resize(node_cnt);

    X0_[0] = BuildTransform(js_.base_trans, js_.base_rot);
    X_parent_[0] = X0_[0];
    v_[0].topRows(3) = js_.base_rot_vel;
    v_[0].bottomRows(3) = js_.base_linear_vel;
    a_C_[0] = SVec::Zero();

    // a_C_[0] = v_[0] x v_joint = v_[0] x v_[0] = 0

    for(size_t i = 1; i < node_cnt; i++)
    {
        const NodeDescription& nd = node_description_[i];
        // X0_[i] is the multiplication of three parts:
        // the transform from fixed base to its parent (X0_[parent_[i]]);
        // transform from its parent to the joint;
        // and the transform generated by joint motion (X_joint).
        SMat X_joint
                = BuildJointTransform(nd.joint_axis, nd.joint_type,
                                      js_.q[i - 1]);
        X_parent_[i] = X_joint * nd.X_parent;
        SVec v_joint = nd.joint_axis * js_.dq[i - 1];

        v_[i] = X_parent_[i] * v_[parent_[i]] + v_joint;
        X0_[i] = X_parent_[i] * X0_[parent_[i]];
        a_C_[i] = MotionCrossProduct(v_[i], v_joint);

        // X0_rot_[i] also have three components:
        // X0_[parent_[i]];
        // transform from parent to rotor;
        // and transform caused by rotor's rotation
        X_joint = BuildJointTransform(nd.joint_axis, nd.joint_type,
                                      js_.q[i - 1] * nd.gear_ratio);
        X_parent_rot_[i] = X_joint * nd.rotor_X_parent;
        v_joint *= nd.gear_ratio;

        v_rot_[i] = X_parent_rot_[i] * v_[parent_[i]] + v_joint;
        X0_rot_[i] = X_parent_rot_[i] * X0_[parent_[i]];
        a_C_rot_[i] = MotionCrossProduct(v_rot_[i], v_joint);
    }
}

Eigen::VectorXd FloatingBaseModel::BiasForces()
{
    if(bias_force_updated_)
        return compensate_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();

    std::vector<SVec> link_forces(node_cnt, SVec::Zero());
    compensate_.resize(node_cnt + 5);

    for(size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        SVec momentum = nd.inertia * v_[i];
        link_forces[i] += ForceCrossProduct(v_[i], momentum);

        momentum = nd.rotor_inertia * v_rot_[i];
        const SVec rot_force = ForceCrossProduct(v_rot_[i], momentum);

        link_forces[parent_[i]]
                += X_parent_[i].transpose() * link_forces[i]
                + X_parent_rot_[i].transpose() * rot_force;

        compensate_(i + 5) = (link_forces[i] + rot_force * nd.gear_ratio)
                             .dot(nd.joint_axis);
    }

    {
        const NodeDescription& nd = node_description_[0];
        SVec& base_force = link_forces[0];
        SVec momentum = nd.inertia * v_[0];
        base_force += ForceCrossProduct(v_[0], momentum);

        compensate_.topRows<6>() = base_force;
    }

    bias_force_updated_ = true;
    return compensate_;
}

Eigen::MatrixXd FloatingBaseModel::MassMatrix()
{
    if(mass_matrix_updated_)
        return mass_matrix_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();
    mass_matrix_ = Eigen::MatrixXd::Zero(node_cnt + 5, node_cnt + 5);
    // tree_inertia[i] is the total inertia of all links in
    // the subtree whose root is link i.
    // This value is also named "composite inertia".
    std::vector<SMat> tree_inertia(node_cnt);

    for(size_t i = 0; i < node_cnt; i++)
    {
        // tree root inertia
        tree_inertia[i] = node_description_[i].inertia;
    }

    for(size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        SVec f_i = tree_inertia[i] * nd.joint_axis;
        const SVec f_rot_i = nd.rotor_inertia * nd.joint_axis * nd.gear_ratio;
        mass_matrix_(i + 5, i + 5)
                = node_description_[i].joint_axis.dot(
                    f_i + f_rot_i * nd.gear_ratio);

        f_i = X_parent_[i].transpose() * f_i
            + X_parent_rot_[i].transpose() * f_rot_i;

        for(size_t j = i; j != 0;)
        {
            const int parent = parent_[j];
            mass_matrix_(parent + 5, i + 5)
                    = node_description_[j].joint_axis.dot(f_i);
            mass_matrix_(i + 5, parent + 5) = mass_matrix_(parent + 5, i + 5);

            j = parent;
            f_i = X_parent_[j].transpose() * f_i;
        }

        mass_matrix_.block<6, 1>(0, i + 5) = f_i;
        mass_matrix_.block<1, 6>(i + 5, 0) = f_i.transpose();

        // backward propagation of tree inertia
        tree_inertia[parent_[i]]
                += X_parent_[i].transpose() * tree_inertia[i] * X_parent_[i]
                + X_parent_rot_[i].transpose()
                * node_description_[i].rotor_inertia
                * X_parent_rot_[i];
    }

    mass_matrix_.topLeftCorner<6, 6>() = tree_inertia[0];

    mass_matrix_updated_ = true;
    return mass_matrix_;
}

Eigen::Vector3d FloatingBaseModel::EEPos(int ee_id) const
{
    assert(static_cast<unsigned>(ee_id) < ee_info_.size());

    const EndEffectorInfo& ee = ee_info_[ee_id];

    return PointTf(MotionTfInverse(X0_[ee.ee_link_id]),
                   ee.ee_local_pos);
}

Eigen::Vector3d FloatingBaseModel::EEVel(int ee_id) const
{
    assert(static_cast<unsigned>(ee_id) < ee_info_.size());

    const EndEffectorInfo& ee = ee_info_[ee_id];

    return X0_[ee.ee_link_id].topLeftCorner(3, 3).transpose()
            * LinearVel(v_[ee.ee_link_id], ee.ee_local_pos);
}

void FloatingBaseModel::DemoInfo()
{
    std::cout << "floating base info" << std::endl;

    for(size_t i = 0; i < node_description_.size(); i++)
    {
        std::cout << "--------------------------------" << std::endl;
        std::cout << "link " << i + 1 << std::endl;
        std::cout << "tf: " << std::endl
                  << X0_[i] << std::endl;
        std::cout << "vel: " << std::endl
                  << v_[i] << std::endl;
    }
}

} /* spatial */

} /* physics */

} /* dog_control */
