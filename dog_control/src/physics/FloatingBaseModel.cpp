#include "dog_control/physics/FloatingBaseModel.h"
#include "dog_control/physics/EigenToolbox.h"
#include "dog_control/physics/SpatialToolbox.h"
#include "dog_control/utils/MiniLog.h"

#include <iostream>

namespace dog_control
{

namespace physics
{

namespace spatial
{

int FloatingBaseModel::AddLink(const NodeDescription &node, int parent)
{
    // the link's parent must have a smaller id
    CHECK(static_cast<unsigned>(parent) <= node_description_.size())
            << "[FloatingBaseModel] "
               "The link's parent must have a smaller id.";

    const int link_id = node_description_.size() + 1;

    // only the first link could have a floating joint
    CHECK((link_id != 1) xor (node.joint_type == floating))
            << "[FloatingBaseModel] "
               " Link " << link_id << " has a floating joint.";
    CHECK((link_id != 1) xor (parent == 0))
            << "[FloatingBaseModel] "
               " Link " << link_id << " connects to the fix base.";

    node_description_.push_back(node);
    parent_.push_back(parent - 1);

    return link_id;
}

int FloatingBaseModel::AddEndEffector(int link_id,
                                      const Eigen::Vector3d &ee_local_pos)
{
    CHECK(static_cast<unsigned>(link_id - 1) < node_description_.size())
            << "[FloatingBaseModel] "
               "End effector attaching to an unknown link.";

    const int ee_id = ee_local_pos.size();

    ee_info_.push_back({ee_local_pos, link_id - 1});

    return ee_id;
}

void FloatingBaseModel::ToggleDiff(bool compute_diff)
{
    compute_diff_ = compute_diff;

    if (compute_diff_)
        InitDiffDepends();
}

void FloatingBaseModel::SetJointMotionState(FBJSCRef stat)
{
    // exclude the floating base
    const size_t joint_size = node_description_.size() - 1;

    CHECK(stat.q.size() == joint_size)
            << "[FloatingBaseModel] "
               "Invalid joint position size " << stat.q.size()
            << " (expected " << joint_size << ").";
    CHECK(stat.dq.size() == joint_size)
            << "[FloatingBaseModel] "
               "Invalid joint velocity size " << stat.dq.size()
            << " (expected " << joint_size << ").";

    js_ = stat;

    kinematics_updated_ = false;
    bias_force_updated_ = false;
    mass_matrix_updated_ = false;
    base_bias_jacob_updated_ = false;

    bias_force_diff_updated_ = false;
    mass_matrix_diff_updated_ = false;
}

void FloatingBaseModel::ForwardKinematics()
{
    if (kinematics_updated_)
        return;

    const size_t node_cnt = node_description_.size();
    const size_t state_cnt = (node_cnt + 5) * 2;
    v_.resize(node_cnt);
    X_parent_.resize(node_cnt);
    X0_.resize(node_cnt);
    X0_inv_.resize(node_cnt);
    a_C_.resize(node_cnt);
    vJ_vq_.resize(node_cnt);

    v_rot_.resize(node_cnt);
    X_parent_rot_.resize(node_cnt);
    X0_rot_.resize(node_cnt);
    a_C_rot_.resize(node_cnt);

    X0_[0] = BuildTransform(js_.base.trans, js_.base.rot);
    X0_inv_[0] = MotionTfInverse(X0_[0]);
    X_parent_[0] = X0_[0];
    v_[0].topRows(3) = js_.base.rot_vel;
    v_[0].bottomRows(3) = js_.base.linear_vel;
    // a_C_[0] = v_[0] x v_joint = v_[0] x v_[0] = 0
    a_C_[0] = SVec::Zero();
    // vJ_vq_[0] = X0_inv_[0] * (v_[0] x v_[0]) = 0
    vJ_vq_[0] = SVec::Zero();

    if (compute_diff_)
    {
        diff_X_parent_.resize(node_cnt);
        diff_X_parent_rot_.resize(node_cnt);
        dv_.resize(node_cnt,
                   std::vector<SVec>(state_cnt, SVec::Zero()));
        daC_.resize(node_cnt,
                    std::vector<SVec>(state_cnt, SVec::Zero()));

        diff_X_parent_[0].setZero();
        dv_[0][node_cnt + 5 ] << 1, 0, 0, 0, 0, 0;
        dv_[0][node_cnt + 6 ] << 0, 1, 0, 0, 0, 0;
        dv_[0][node_cnt + 7 ] << 0, 0, 1, 0, 0, 0;
        dv_[0][node_cnt + 8 ] << 0, 0, 0, 1, 0, 0;
        dv_[0][node_cnt + 9 ] << 0, 0, 0, 0, 1, 0;
        dv_[0][node_cnt + 10] << 0, 0, 0, 0, 0, 1;
    }

    for (size_t i = 1; i < node_cnt; i++)
    {
        const NodeDescription& nd = node_description_[i];
        const int parent = parent_[i];
        // X0_[i] is the multiplication of three parts:
        // the transform from fixed base to its parent (X0_[parent_[i]]);
        // transform from its parent to the joint;
        // and the transform generated by joint motion (X_joint).
        const SMat X_joint
                = BuildJointTransform(nd.joint_axis, nd.joint_type,
                                      js_.q[i - 1]);
        X_parent_[i] = X_joint * nd.X_parent;
        SVec v_joint = nd.joint_axis * js_.dq[i - 1];

        v_[i] = X_parent_[i] * v_[parent] + v_joint;
        X0_[i] = X_parent_[i] * X0_[parent];
        X0_inv_[i] = MotionTfInverse(X0_[i]);
        a_C_[i] = MotionCrossProduct(v_[i], v_joint);
        vJ_vq_[i] = vJ_vq_[parent] + X0_inv_[i] * a_C_[i];

        // X0_rot_[i] also have three components:
        // X0_[parent_[i]];
        // transform from parent to rotor;
        // and transform caused by rotor's rotation
        const SMat X_joint_rot
                = BuildJointTransform(nd.joint_axis, nd.joint_type,
                                      js_.q[i - 1] * nd.gear_ratio);
        X_parent_rot_[i] = X_joint_rot * nd.rotor_X_parent;
        SVec v_joint_rot = v_joint * nd.gear_ratio;

        v_rot_[i] = X_parent_rot_[i] * v_[parent] + v_joint_rot;
        X0_rot_[i] = X_parent_rot_[i] * X0_[parent];
        a_C_rot_[i] = MotionCrossProduct(v_rot_[i], v_joint_rot);

        if (compute_diff_)
        {
            diff_X_parent_[i]
                    = BuildJointTransformDiff(nd.joint_axis, nd.joint_type,
                                              js_.q[i - 1])
                    * nd.X_parent;
            diff_X_parent_rot_[i]
                    = BuildJointTransformDiff(nd.joint_axis, nd.joint_type,
                                              js_.q[i - 1] * nd.gear_ratio)
                    * nd.rotor_X_parent;

            for (size_t j : kin_diff_deps_[i])
            {
                dv_[i][j] = X_parent_[i] * dv_[parent][j];
            }

            dv_[i][i + 5] += diff_X_parent_[i] * v_[parent];
            dv_[i][i + 5 + node_cnt + 5] += nd.joint_axis;

            for (size_t j : kin_diff_deps_[i])
            {
                daC_[i][j] = MotionCrossProduct(dv_[i][j], v_joint);
            }

            daC_[i][i + 5 + node_cnt + 5]
                    += MotionCrossProduct(v_[i], nd.joint_axis);
        }
    }

    kinematics_updated_ = true;
}

Eigen::VectorXd FloatingBaseModel::BiasForces()
{
    if (bias_force_updated_)
        return compensate_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();

    std::vector<SVec> link_forces(node_cnt, SVec::Zero());
    compensate_.resize(node_cnt + 5);

    // a_cor_total[i] is the total Coriolis acceleration of link i,
    // expressed in its own frame.
    // So that Coriolis acceleration of rotor i is
    // X_parent_rot_[i] * a_cor_total[parent_[i]] + a_C_rot_[i].
    std::vector<SVec> a_cor_total(node_cnt);
    a_cor_total[0] = SVec::Zero();

    for (size_t i = 1; i < node_cnt; i++)
    {
        a_cor_total[i]
                = X_parent_[i] * a_cor_total[parent_[i]] + a_C_[i];
    }

    for (size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        const int parent = parent_[i];
        SVec momentum = nd.inertia * v_[i];
        link_forces[i] += nd.inertia * a_cor_total[i]
                          + ForceCrossProduct(v_[i], momentum);

        momentum = nd.rotor_inertia * v_rot_[i];
        const SVec rot_force
                = nd.rotor_inertia
                  * (X_parent_rot_[i] * a_cor_total[parent] + a_C_rot_[i])
                  + ForceCrossProduct(v_rot_[i], momentum);

        link_forces[parent]
                += (X_parent_[i].transpose() * link_forces[i]
                    + X_parent_rot_[i].transpose() * rot_force);

        compensate_(i + 5) = (link_forces[i] + rot_force * nd.gear_ratio)
                             .dot(nd.joint_axis);
    }

    {
        const NodeDescription& nd = node_description_[0];
        SVec& base_force = link_forces[0];
        SVec momentum = nd.inertia * v_[0];
        base_force += nd.inertia * a_C_[0]
                      + ForceCrossProduct(v_[0], momentum);

        compensate_.topRows<6>() = base_force;
    }

    bias_force_updated_ = true;
    return compensate_;
}

std::vector<Eigen::VectorXd> FloatingBaseModel::BiasForceDiff()
{
    if (bias_force_diff_updated_)
        return bias_diff_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();
    const size_t joint_cnt = node_cnt + 5;
    const size_t state_cnt = joint_cnt * 2;
    bias_diff_.resize(state_cnt, Eigen::VectorXd::Zero(node_cnt + 5));

    std::vector<SVec> link_forces(node_cnt, SVec::Zero());
    std::vector<SVec> a_cor_total(node_cnt);
    std::vector<std::vector<SVec>> link_f_diff(
                node_cnt, std::vector<SVec>(state_cnt, SVec::Zero()));
    std::vector<std::vector<SVec>> a_cor_diff(
                node_cnt, std::vector<SVec>(state_cnt, SVec::Zero()));

    a_cor_total[0] = SVec::Zero();

    for (size_t i = 1; i < node_cnt; i++)
    {
        const int parent = parent_[i];
        a_cor_total[i]
                = X_parent_[i] * a_cor_total[parent] + a_C_[i];

        for (size_t j : kin_diff_deps_[i])
        {
            a_cor_diff[i][j]
                    = X_parent_[i] * a_cor_diff[parent][j] + daC_[i][j];
        }

        a_cor_diff[i][i + 5]
                += diff_X_parent_[i] * a_cor_total[parent];
    }

    for (size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        const int parent = parent_[i];
        SVec momentum = nd.inertia * v_[i];
        link_forces[i] += nd.inertia * a_cor_total[i]
                          + ForceCrossProduct(v_[i], momentum);

        for (size_t j : bias_diff_deps_[i])
        {
            link_f_diff[i][j] += nd.inertia * a_cor_diff[i][j]
                    + ForceCrossProduct(dv_[i][j], momentum)
                    + ForceCrossProduct(v_[i], nd.inertia * dv_[i][j]);
        }

        momentum = nd.rotor_inertia * v_rot_[i];
        const SVec rot_force
                = nd.rotor_inertia
                  * (X_parent_rot_[i] * a_cor_total[parent] + a_C_rot_[i])
                  + ForceCrossProduct(v_rot_[i], momentum);

        link_forces[parent]
                += (X_parent_[i].transpose() * link_forces[i]
                    + X_parent_rot_[i].transpose() * rot_force);

        for (size_t j : bias_diff_deps_[i])
        {
            link_f_diff[parent_[i]][j]
                    += X_parent_[i].transpose() * link_f_diff[i][j];
        }

        link_f_diff[parent_[i]][i + 5]
                += diff_X_parent_[i].transpose() * link_forces[i];

        for (size_t j : bias_diff_deps_[i])
        {
            bias_diff_[j](i + 5) = nd.joint_axis.dot(link_f_diff[i][j]);
        }
    }

    {
        const NodeDescription& nd = node_description_[0];
        SVec momentum = nd.inertia * v_[0];

        for (size_t j = joint_cnt; j < joint_cnt + 6; j++)
        {
            link_f_diff[0][j]
                    += ForceCrossProduct(dv_[0][j], momentum)
                    + ForceCrossProduct(v_[0], nd.inertia * dv_[0][j]);
        }

        for (size_t j = 0; j < state_cnt; j++)
        {
            bias_diff_[j].head<6>() = link_f_diff[0][j];
        }
    }

    bias_force_diff_updated_ = true;
    return bias_diff_;
}

SMat FloatingBaseModel::BaseForceJacobian()
{
    if (base_bias_jacob_updated_)
        return base_bias_jacob_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();

    // link spatial force's jacobian wrt base motion
    std::vector<SMat> link_jacob(node_cnt, SMat::Zero());

    for (size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        link_jacob[i]
                += ForceCrossMat(v_[i]) * nd.inertia
                - ForceCrossMat(nd.inertia * v_[i]);

        const SMat rot_jacob
                = ForceCrossMat(v_rot_[i]) * nd.rotor_inertia
                - ForceCrossMat(nd.rotor_inertia * v_rot_[i]);

        link_jacob[parent_[i]]
                += X_parent_[i].transpose() * link_jacob[i] * X_parent_[i]
                + X_parent_rot_[i].transpose() * rot_jacob * X_parent_rot_[i];
    }

    {
        const NodeDescription& nd = node_description_[0];
        base_bias_jacob_ = link_jacob[0];
        SVec momentum = nd.inertia * v_[0];
        base_bias_jacob_
                += ForceCrossMat(v_[0]) * nd.inertia
                - ForceCrossMat(momentum);
    }

    base_bias_jacob_updated_ = true;
    return base_bias_jacob_;
}

Eigen::MatrixXd FloatingBaseModel::MassMatrix()
{
    if (mass_matrix_updated_)
        return mass_matrix_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();
    mass_matrix_ = Eigen::MatrixXd::Zero(node_cnt + 5, node_cnt + 5);
    // tree_inertia[i] is the total inertia of all links in
    // the subtree whose root is link i.
    // This value is also named "composite inertia".
    tree_inertia_.resize(node_cnt);

    for (size_t i = 0; i < node_cnt; i++)
    {
        // tree root inertia
        tree_inertia_[i] = node_description_[i].inertia;
    }

    for (size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        SVec f_i = tree_inertia_[i] * nd.joint_axis;
        const SVec f_rot_i = nd.rotor_inertia * nd.joint_axis * nd.gear_ratio;
        mass_matrix_(i + 5, i + 5)
                = node_description_[i].joint_axis.dot(
                    f_i + f_rot_i * nd.gear_ratio);

        f_i = X_parent_[i].transpose() * f_i
            + X_parent_rot_[i].transpose() * f_rot_i;

        for (size_t j = parent_[i]; j != 0;)
        {
            // Note that spatial force f_i is expressed in frame j.
            // So in order to find the force needed for joint[j],
            // we needs joint_axis[j] * f_i.

            const double mij = node_description_[j].joint_axis.dot(f_i);
            mass_matrix_(j + 5, i + 5) = mij;
            mass_matrix_(i + 5, j + 5) = mij;

            f_i = X_parent_[j].transpose() * f_i;
            j = parent_[j];
        }

        mass_matrix_.block<6, 1>(0, i + 5) = f_i;
        mass_matrix_.block<1, 6>(i + 5, 0) = f_i.transpose();

        // backward propagation of tree inertia
        tree_inertia_[parent_[i]]
                += (X_parent_[i].transpose() * tree_inertia_[i] * X_parent_[i]
                + X_parent_rot_[i].transpose()
                * node_description_[i].rotor_inertia
                * X_parent_rot_[i]);
    }

    mass_matrix_.topLeftCorner<6, 6>() = tree_inertia_[0];

    mass_matrix_updated_ = true;
    return mass_matrix_;
}

FloatingBaseModel::Tensor3D FloatingBaseModel::MassMatrixDiff()
{
    if (mass_matrix_diff_updated_)
        return mass_matrix_diff_;

    MassMatrix();

    const size_t node_cnt = node_description_.size();
    const size_t joint_cnt = node_cnt - 1;
    mass_matrix_diff_.resize(
                joint_cnt, Eigen::MatrixXd::Zero(node_cnt + 5, node_cnt + 5));
    // dMass / dxbase = 0
    // dtree_inertia / dxbase = 0

    std::vector<Tensor3D> tree_inertia_diff(
                node_cnt, Tensor3D(joint_cnt, SMat::Zero()));
    std::vector<SVec> f_diff(joint_cnt);

    for (size_t i = joint_cnt; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        SVec f_i = tree_inertia_[i] * nd.joint_axis;

        for (SVec& item : f_diff)
            item.setZero();

//        for (size_t j = 1; j < node_cnt; j++)
        for (size_t j : mass_diff_deps_[i])
        {
            f_diff[j] = tree_inertia_diff[i][j] * nd.joint_axis;
        }

        const SVec f_rot_i = nd.rotor_inertia * nd.joint_axis * nd.gear_ratio;
//        mass_matrix_(i + 5, i + 5)
//                = node_description_[i].joint_axis.dot(
//                    f_i + f_rot_i * nd.gear_ratio);

        for (size_t j : mass_diff_deps_[i])
        {
            mass_matrix_diff_[j](i + 5, i + 5)
                    = node_description_[i].joint_axis.dot(f_diff[j]);
        }

        for (size_t j : mass_diff_deps_[i])
        {
            f_diff[j] = X_parent_[i].transpose() * f_diff[j];
        }

        f_diff[i - 1] += diff_X_parent_[i].transpose() * f_i
                + diff_X_parent_rot_[i].transpose() * f_rot_i;

        f_i = X_parent_[i].transpose() * f_i
            + X_parent_rot_[i].transpose() * f_rot_i;

        for (size_t k = parent_[i]; k != 0;)
        {
            // Note that spatial force f_i is expressed in frame j.
            // So in order to find the force needed for joint[j],
            // we needs joint_axis[j] * f_i.
//            mass_matrix_(k + 5, i + 5)
//                    = node_description_[k].joint_axis.dot(f_i);
//            mass_matrix_(i + 5, k + 5) = mass_matrix_(k + 5, i + 5);

            for (size_t j : mass_diff_deps_[k])
            {
                const double mikj
                        = node_description_[k].joint_axis.dot(f_diff[j]);
                mass_matrix_diff_[j](k + 5, i + 5) = mikj;
                mass_matrix_diff_[j](i + 5, k + 5) = mikj;
            }

            for (size_t j : mass_diff_deps_[k])
            {
                f_diff[j] = X_parent_[k].transpose() * f_diff[j];
            }

            f_diff[k - 1] += diff_X_parent_[k].transpose() * f_i;

            f_i = X_parent_[k].transpose() * f_i;
            k = parent_[k];
        }

//        mass_matrix_.block<6, 1>(0, i + 5) = f_i;
//        mass_matrix_.block<1, 6>(i + 5, 0) = f_i.transpose();

        for (size_t j : chain_deps_[i])
        {
            mass_matrix_diff_[j].block<6, 1>(0, i + 5) = f_diff[j];
            mass_matrix_diff_[j].block<1, 6>(i + 5, 0)
                    = f_diff[j].transpose();
        }

        mass_matrix_diff_[i - 1].block<6, 1>(0, i + 5) = f_diff[i - 1];
        mass_matrix_diff_[i - 1].block<1, 6>(i + 5, 0)
                = f_diff[i - 1].transpose();

        // backward propagation of tree inertia diff
        for (size_t j : mass_diff_deps_[i])
        {
            tree_inertia_diff[parent_[i]][j]
                    += X_parent_[i].transpose() * tree_inertia_diff[i][j]
                    * X_parent_[i];
        }

        const SMat iner_diff
                = diff_X_parent_[i].transpose()
                * tree_inertia_[i] * X_parent_[i]
                + diff_X_parent_rot_[i].transpose()
                * node_description_[i].rotor_inertia * X_parent_rot_[i];
        tree_inertia_diff[parent_[i]][i - 1]
                += iner_diff + iner_diff.transpose();
    }

    for (size_t j = 0; j < joint_cnt; j++)
        mass_matrix_diff_[j].topLeftCorner<6, 6>() = tree_inertia_diff[0][j];

    mass_matrix_diff_updated_ = true;
    return mass_matrix_diff_;
}

Eigen::Vector3d FloatingBaseModel::EEPos(int ee_id) const
{
    CHECK(static_cast<unsigned>(ee_id) < ee_info_.size())
            << "[FloatingBaseModel] "
               "Invalid end effector id " << ee_id << ".";

    const EndEffectorInfo& ee = ee_info_[ee_id];

    return PointTf(X0_inv_[ee.ee_link_id], ee.ee_local_pos);
}

Eigen::Vector3d FloatingBaseModel::EEVel(int ee_id) const
{
    CHECK(static_cast<unsigned>(ee_id) < ee_info_.size())
            << "[FloatingBaseModel] "
               "Invalid end effector id " << ee_id << ".";

    const EndEffectorInfo& ee = ee_info_[ee_id];

    return X0_inv_[ee.ee_link_id].topLeftCorner(3, 3)
            * LinearVel(v_[ee.ee_link_id], ee.ee_local_pos);
}

void FloatingBaseModel::DemoInfo()
{
    std::cout << "floating base info" << std::endl;

    for (size_t i = 0; i < node_description_.size(); i++)
    {
        std::cout << "--------------------------------" << std::endl;
        std::cout << "link " << i + 1 << std::endl;
        std::cout << "tf: " << std::endl
                  << X0_[i] << std::endl;
        std::cout << "vel: " << std::endl
                  << v_[i] << std::endl;
        std::cout << "inertia: " << std::endl
                  << node_description_[i].inertia << std::endl;
    }
}

void FloatingBaseModel::InitDiffDepends()
{
    const int joint_cnt = node_description_.size() - 1;
    const int dof = joint_cnt + 6;
    mass_diff_deps_.resize(joint_cnt + 1, std::vector<size_t>());
    chain_deps_.resize(joint_cnt + 1, std::vector<size_t>());
    kin_diff_deps_.resize(joint_cnt + 1, std::vector<size_t>());
    bias_diff_deps_.resize(joint_cnt + 1, std::vector<size_t>());

    for (int i = joint_cnt; i > 0; i--)
    {
        // spatial velocities can affect kinematics and bias of any node
        for (int k = dof; k < 6 + dof; k++)
        {
            kin_diff_deps_[i].push_back(k);
            bias_diff_deps_[i].push_back(k);
        }
    }

    for (int i = joint_cnt; i > 0; i--)
    {
        for (int k = i; k != 0; k = parent_[k])
        {
            chain_deps_[k].push_back(i - 1);

            if (k != i)
                chain_deps_[i].push_back(k - 1);

            // if node i is the offspring of node k,
            // joint i can affect mass property of node k
            if (k != i)
                mass_diff_deps_[k].push_back(i - 1);

            // joint k can affect kinematics of node i
            kin_diff_deps_[i].push_back(k + 5);
            kin_diff_deps_[i].push_back(k + 5 + dof);

            // joint i can affect bias forces on node k
            // and vice versa.
            bias_diff_deps_[k].push_back(i + 5);
            bias_diff_deps_[k].push_back(i + 5 + dof);

            if (k != i)
            {
                bias_diff_deps_[i].push_back(k + 5);
                bias_diff_deps_[i].push_back(k + 5 + dof);
            }
        }
    }
}

} /* spatial */

} /* physics */

} /* dog_control */
