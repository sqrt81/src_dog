#include "dog_control/physics/FloatingBaseModel.h"
#include "dog_control/physics/EigenToolbox.h"
#include "dog_control/physics/SpatialToolbox.h"
#include "dog_control/utils/MiniLog.h"

#include <iostream>

namespace dog_control
{

namespace physics
{

namespace spatial
{

int FloatingBaseModel::AddLink(const NodeDescription &node, int parent)
{
    // the link's parent must have a smaller id
    CHECK(static_cast<unsigned>(parent) <= node_description_.size())
            << "[FloatingBaseModel] "
               "The link's parent must have a smaller id.";

    const int link_id = node_description_.size() + 1;

    // only the first link could have a floating joint
    CHECK((link_id != 1) xor (node.joint_type == floating))
            << "[FloatingBaseModel] "
               " Link " << link_id << " has a floating joint.";
    CHECK((link_id != 1) xor (parent == 0))
            << "[FloatingBaseModel] "
               " Link " << link_id << " connects to the fix base.";

    node_description_.push_back(node);
    parent_.push_back(parent - 1);

    return link_id;
}

int FloatingBaseModel::AddEndEffector(int link_id,
                                      const Eigen::Vector3d &ee_local_pos)
{
    CHECK(static_cast<unsigned>(link_id - 1) < node_description_.size())
            << "[FloatingBaseModel] "
               "End effector attaching to an unknown link.";

    const int ee_id = ee_local_pos.size();

    ee_info_.push_back({ee_local_pos, link_id - 1});

    return ee_id;
}

void FloatingBaseModel::SetJointMotionState(FBJSCRef stat)
{
    // exclude the floating base
    const size_t joint_size = node_description_.size() - 1;

    CHECK(stat.q.size() == joint_size)
            << "[FloatingBaseModel] "
               "Invalid joint position size " << stat.q.size()
            << " (expected " << joint_size << ").";
    CHECK(stat.dq.size() == joint_size)
            << "[FloatingBaseModel] "
               "Invalid joint velocity size " << stat.dq.size()
            << " (expected " << joint_size << ").";

    js_ = stat;

    kinematics_updated_ = false;
    bias_force_updated_ = false;
    mass_matrix_updated_ = false;
    base_bias_jacob_updated_ = false;
}

void FloatingBaseModel::ForwardKinematics()
{
    if (kinematics_updated_)
        return;

    const size_t node_cnt = node_description_.size();
    v_.resize(node_cnt);
    X_parent_.resize(node_cnt);
    X0_.resize(node_cnt);
    X0_inv_.resize(node_cnt);
    a_C_.resize(node_cnt);
    vJ_vq_.resize(node_cnt);

    v_rot_.resize(node_cnt);
    X_parent_rot_.resize(node_cnt);
    X0_rot_.resize(node_cnt);
    a_C_rot_.resize(node_cnt);

    X0_[0] = BuildTransform(js_.base.trans, js_.base.rot);
    X0_inv_[0] = MotionTfInverse(X0_[0]);
    X_parent_[0] = X0_[0];
    v_[0].topRows(3) = js_.base.rot_vel;
    v_[0].bottomRows(3) = js_.base.linear_vel;
    // a_C_[0] = v_[0] x v_joint = v_[0] x v_[0] = 0
    a_C_[0] = SVec::Zero();
    // vJ_vq_[0] = X0_inv_[0] * (v_[0] x v_[0]) = 0
    vJ_vq_[0] = SVec::Zero();

    for (size_t i = 1; i < node_cnt; i++)
    {
        const NodeDescription& nd = node_description_[i];
        // X0_[i] is the multiplication of three parts:
        // the transform from fixed base to its parent (X0_[parent_[i]]);
        // transform from its parent to the joint;
        // and the transform generated by joint motion (X_joint).
        SMat X_joint
                = BuildJointTransform(nd.joint_axis, nd.joint_type,
                                      js_.q[i - 1]);
        X_parent_[i] = X_joint * nd.X_parent;
        SVec v_joint = nd.joint_axis * js_.dq[i - 1];

        v_[i] = X_parent_[i] * v_[parent_[i]] + v_joint;
        X0_[i] = X_parent_[i] * X0_[parent_[i]];
        X0_inv_[i] = MotionTfInverse(X0_[i]);
        a_C_[i] = MotionCrossProduct(v_[i], v_joint);
        vJ_vq_[i] = vJ_vq_[parent_[i]] + X0_inv_[i] * a_C_[i];

        // X0_rot_[i] also have three components:
        // X0_[parent_[i]];
        // transform from parent to rotor;
        // and transform caused by rotor's rotation
        X_joint = BuildJointTransform(nd.joint_axis, nd.joint_type,
                                      js_.q[i - 1] * nd.gear_ratio);
        X_parent_rot_[i] = X_joint * nd.rotor_X_parent;
        v_joint *= nd.gear_ratio;

        v_rot_[i] = X_parent_rot_[i] * v_[parent_[i]] + v_joint;
        X0_rot_[i] = X_parent_rot_[i] * X0_[parent_[i]];
        a_C_rot_[i] = MotionCrossProduct(v_rot_[i], v_joint);
    }

    kinematics_updated_ = true;
}

Eigen::VectorXd FloatingBaseModel::BiasForces()
{
    if (bias_force_updated_)
        return compensate_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();

    std::vector<SVec> link_forces(node_cnt, SVec::Zero());
    compensate_.resize(node_cnt + 5);

    // a_cor_total[i] is the total Coriolis acceleration of link i,
    // expressed in its own frame.
    // So that Coriolis acceleration of rotor i is
    // X_parent_rot_[i] * a_cor_total[parent_[i]] + a_C_rot_[i].
    std::vector<SVec> a_cor_total(node_cnt);
    a_cor_total[0] = SVec::Zero();

    for (size_t i = 1; i < node_cnt; i++)
    {
        a_cor_total[i]
                = X_parent_[i] * a_cor_total[parent_[i]] + a_C_[i];
    }

    for (size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        SVec momentum = nd.inertia * v_[i];
        link_forces[i] += nd.inertia * a_cor_total[i]
                          + ForceCrossProduct(v_[i], momentum);

        momentum = nd.rotor_inertia * v_rot_[i];
        const SVec rot_force
                = nd.rotor_inertia
                  * (X_parent_rot_[i] * a_cor_total[parent_[i]] + a_C_rot_[i])
                  + ForceCrossProduct(v_rot_[i], momentum);

        link_forces[parent_[i]]
                += (X_parent_[i].transpose() * link_forces[i]
                    + X_parent_rot_[i].transpose() * rot_force);

        compensate_(i + 5) = (link_forces[i] + rot_force * nd.gear_ratio)
                             .dot(nd.joint_axis);
    }

    {
        const NodeDescription& nd = node_description_[0];
        SVec& base_force = link_forces[0];
        SVec momentum = nd.inertia * v_[0];
        base_force += nd.inertia * a_C_[0]
                      + ForceCrossProduct(v_[0], momentum);

        compensate_.topRows<6>() = base_force;
    }

    bias_force_updated_ = true;
    return compensate_;
}

SMat FloatingBaseModel::BaseForceJacobian()
{
    if (base_bias_jacob_updated_)
        return base_bias_jacob_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();

    // link spatial force's jacobian wrt base motion
    std::vector<SMat> link_jacob(node_cnt, SMat::Zero());

    for (size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        link_jacob[i]
                += ForceCrossMat(v_[i]) * nd.inertia
                - ForceCrossMat(nd.inertia * v_[i]);

        const SMat rot_jacob
                = ForceCrossMat(v_rot_[i]) * nd.rotor_inertia
                - ForceCrossMat(nd.rotor_inertia * v_rot_[i]);

        link_jacob[parent_[i]]
                += X_parent_[i].transpose() * link_jacob[i] * X_parent_[i]
                + X_parent_rot_[i].transpose() * rot_jacob * X_parent_rot_[i];
    }

    {
        const NodeDescription& nd = node_description_[0];
        base_bias_jacob_ = link_jacob[0];
        SVec momentum = nd.inertia * v_[0];
        base_bias_jacob_
                += ForceCrossMat(v_[0]) * nd.inertia
                - ForceCrossMat(momentum);
    }

    base_bias_jacob_updated_ = true;
    return base_bias_jacob_;
}

Eigen::MatrixXd FloatingBaseModel::MassMatrix()
{
    if (mass_matrix_updated_)
        return mass_matrix_;

    ForwardKinematics();

    const size_t node_cnt = node_description_.size();
    mass_matrix_ = Eigen::MatrixXd::Zero(node_cnt + 5, node_cnt + 5);
    // tree_inertia[i] is the total inertia of all links in
    // the subtree whose root is link i.
    // This value is also named "composite inertia".
    std::vector<SMat> tree_inertia(node_cnt);

    for (size_t i = 0; i < node_cnt; i++)
    {
        // tree root inertia
        tree_inertia[i] = node_description_[i].inertia;
    }

    for (size_t i = node_cnt - 1; i > 0; i--)
    {
        const NodeDescription& nd = node_description_[i];
        SVec f_i = tree_inertia[i] * nd.joint_axis;
        const SVec f_rot_i = nd.rotor_inertia * nd.joint_axis * nd.gear_ratio;
        mass_matrix_(i + 5, i + 5)
                = node_description_[i].joint_axis.dot(
                    f_i + f_rot_i * nd.gear_ratio);

        f_i = X_parent_[i].transpose() * f_i
            + X_parent_rot_[i].transpose() * f_rot_i;

        for (size_t j = parent_[i]; j != 0;)
        {
            // Note that spatial force f_i is expressed in frame j.
            // So in order to find the force needed for joint[j],
            // we needs joint_axis[j] * f_i.
            mass_matrix_(j + 5, i + 5)
                    = node_description_[j].joint_axis.dot(f_i);
            mass_matrix_(i + 5, j + 5) = mass_matrix_(j + 5, i + 5);

            f_i = X_parent_[j].transpose() * f_i;
            j = parent_[j];
        }

        mass_matrix_.block<6, 1>(0, i + 5) = f_i;
        mass_matrix_.block<1, 6>(i + 5, 0) = f_i.transpose();

        // backward propagation of tree inertia
        tree_inertia[parent_[i]]
                += (X_parent_[i].transpose() * tree_inertia[i] * X_parent_[i]
                + X_parent_rot_[i].transpose()
                * node_description_[i].rotor_inertia
                * X_parent_rot_[i]);
    }

    mass_matrix_.topLeftCorner<6, 6>() = tree_inertia[0];

    mass_matrix_updated_ = true;
    return mass_matrix_;
}

Eigen::Vector3d FloatingBaseModel::EEPos(int ee_id) const
{
    CHECK(static_cast<unsigned>(ee_id) < ee_info_.size())
            << "[FloatingBaseModel] "
               "Invalid end effector id " << ee_id << ".";

    const EndEffectorInfo& ee = ee_info_[ee_id];

    return PointTf(X0_inv_[ee.ee_link_id], ee.ee_local_pos);
}

Eigen::Vector3d FloatingBaseModel::EEVel(int ee_id) const
{
    CHECK(static_cast<unsigned>(ee_id) < ee_info_.size())
            << "[FloatingBaseModel] "
               "Invalid end effector id " << ee_id << ".";

    const EndEffectorInfo& ee = ee_info_[ee_id];

    return X0_inv_[ee.ee_link_id].topLeftCorner(3, 3)
            * LinearVel(v_[ee.ee_link_id], ee.ee_local_pos);
}

void FloatingBaseModel::DemoInfo()
{
    std::cout << "floating base info" << std::endl;

    for (size_t i = 0; i < node_description_.size(); i++)
    {
        std::cout << "--------------------------------" << std::endl;
        std::cout << "link " << i + 1 << std::endl;
        std::cout << "tf: " << std::endl
                  << X0_[i] << std::endl;
        std::cout << "vel: " << std::endl
                  << v_[i] << std::endl;
        std::cout << "inertia: " << std::endl
                  << node_description_[i].inertia << std::endl;
    }
}

} /* spatial */

} /* physics */

} /* dog_control */
